# GitHub Actions 핵심 개념 심화 가이드

## 1. 개요

이 문서는 GitHub Actions 워크플로우의 가장 근본적인 세 가지 핵심 개념인 **러너(Runner)**, **액션(Action)**, 그리고 **컨텍스트/outputs**에 대해 깊이 있게 설명합니다.

### 이런 분들이 읽으면 좋아요

- **CI/CD 파이프라인을 직접 수정하거나 관리**해야 하는 코어 개발자
- GitHub Actions의 **동작 원리를 근본적으로 이해**하고 싶은 분
- 배포 과정에서 발생하는 **문제를 해결(Troubleshooting)**해야 하는 분

이 개념들을 이해하면 워크플로우가 "어떻게" 동작하는지 명확하게 파악하고, 향후 CI/CD 파이프라인을 직접 수정하거나 트러블슈팅하는 데 큰 도움이 됩니다.

---

## 2. 가상 컴퓨터: 러너(Runner)

GitHub Actions의 모든 작업(Job)은 GitHub가 제공하는 일회용 가상 컴퓨터에서 실행되며, 이 가상 컴퓨터를 **러너(Runner)**라고 부릅니다.

- **`runs-on: ubuntu-latest`의 의미:** "이 Job을 실행할 러너의 OS로 최신 버전의 우분투 리눅스를 사용하겠다"는 선언입니다.
- **실행 환경:** Job이 시작될 때마다 깨끗하게 포맷된 새로운 러너가 할당됩니다. 이 러너는 OS와 일부 기본 도구만 설치된 텅 빈 상태이며, 우리 프로젝트 코드는 아직 존재하지 않습니다.
- **표준 환경:** 대부분의 웹 개발 CI/CD는 실제 서버 환경과 유사하고 호환성이 높은 리눅스 러너를 표준으로 사용합니다.

---

## 3. 외부 도구: 마켓플레이스 액션(Action)

워크플로우에서 `uses: actions/checkout@v4`와 같이 `uses` 키워드로 참조되는 부분은 우리 저장소에 없는 코드입니다. 이것은 GitHub 마켓플레이스에 공개된 **재사용 가능한 외부 프로그램(Action)**을 가져와 사용하는 것입니다.

- **동작 원리:**
  1.  러너는 `uses:` 구문을 만나면, 마켓플레이스에서 해당 주소(`actions/checkout`)의 액션을 찾습니다.
  2.  해당 액션의 소스 코드를 러너(가상 컴퓨터) 안으로 **실시간으로 다운로드**합니다.
  3.  다운로드한 액션(프로그램)을 러너 위에서 실행합니다.

- **`actions/checkout@v4`의 역할:** 우리 프로젝트 저장소의 코드를 러너 안으로 복사해오는 역할을 수행하는 가장 기본적인 액션입니다.
- **`dorny/paths-filter@v2`의 역할:** 러너에 복사된 코드 중 어떤 파일/폴더가 변경되었는지 분석하는 역할을 수행하는 외부 액션입니다.

이 방식은 마치 `npm install` 명령으로 외부 라이브러리를 `node_modules`에 다운로드하여 사용하는 것과 매우 유사합니다.

---

## 4. 메모리 데이터: 컨텍스트와 `outputs`

`outputs`, `steps`, `needs`, `github` 등 워크플로우에서 `${{...}}` 구문으로 접근하는 데이터들은 파일이나 폴더가 아닌, **러너의 메모리(RAM)에 존재하는 데이터 구조(Context)**입니다.

### 4.1. `outputs`의 두 종류

`outputs`는 범위와 목적에 따라 두 종류로 나뉩니다.

- **1. 스텝(Step)의 `outputs` (Job 내부용):**
  - **정의:** 한 `step`이 실행된 후, `::set-output` 같은 특별한 명령을 통해 생성하는 **"중간 결과물"**입니다.
  - **범위:** 오직 **같은 Job 내의 다른 `step`들만** 이 `outputs`을 `steps.<ID>.outputs.<이름>` 형태로 참조할 수 있습니다.
  - **비유:** 한 부서 내에서 A직원이 B직원에게 전달하는 **내부 메모**.

- **2. 잡(Job)의 `outputs` (Job 외부용):**
  - **정의:** 한 `Job`이 모든 실행을 마친 후, 다른 `Job`에게 전달하기 위해 Job 최상단에 `outputs:` 키로 명시적으로 선언하는 **"최종 보고서"**입니다.
  - **범위:** `needs` 컨텍스트를 통해 **다른 Job에서** `needs.<Job이름>.outputs.<이름>` 형태로 참조할 수 있습니다.
  - **비유:** A부서가 업무를 마친 후 B부서에 전달하는 **공식 보고서**.

### 4.2. 데이터 흐름 예시

우리 워크플로우의 `changes` Job은 이 두 `outputs`를 모두 사용합니다.

```yaml
changes:
  outputs: # (2) Job의 "최종 보고서"를 정의합니다.
    app: ${{ steps.filter.outputs.app }} # (3) 내용은 Step의 "중간 결과물"로 채웁니다.
  steps:
    - uses: dorny/paths-filter@v2
      id: filter
      # (1) 이 스텝이 실행되면 Step의 "중간 결과물"(outputs)이 메모리에 생성됩니다.
```

1.  `dorny/paths-filter` 스텝이 실행되고, 그 결과로 `steps.filter.outputs.app`이라는 **중간 결과물**이 메모리에 생성됩니다.
2.  `changes` Job의 `outputs` 섹션은 이 **중간 결과물**을 참조하여,
3.  다른 Job이 사용할 수 있는 **최종 보고서**를 만듭니다.
4.  이후 `build-and-deploy` Job은 `needs.changes.outputs.app`이라는 주소로 이 "최종 보고서"를 조회하여 사용하는 것입니다.
